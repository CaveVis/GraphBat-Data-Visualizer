# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

#####
#A lot of the code is hardcoded just for testing sake, but I'll change it
#####

from PyQt5 import QtCore, QtGui, QtWidgets
import matplotlib
import matplotlib.pyplot as plt
matplotlib.use('Qt5Agg')
from PyQt5.QtWidgets import QFileDialog, QDateTimeEdit, QDockWidget, QTabWidget, QTextEdit
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg, NavigationToolbar2QT as Navi
from matplotlib.figure import Figure
import datetime
import seaborn as sns
import pandas as pd
import numpy as py
import sip # can be installed : pip install sip
import os
import json
import shutil
import traceback


#Canvas class
class MatplotlibCanvas(FigureCanvasQTAgg):
    def __init__(self,parent=None,width=5, height = 5, dpi = 120):
        f = Figure(figsize = (width,height),dpi = dpi)
        self.axes= f.add_subplot(111)
        super(MatplotlibCanvas,self).__init__(f)
        f.tight_layout()

class AnomalyDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, anomaly_info=None):
        super(AnomalyDialog, self).__init__(parent)
        self.setWindowTitle("Anomaly Detection")
        self.resize(600, 400)
        
        # Main layout
        self.layout = QtWidgets.QVBoxLayout(self)
        
        #Detailed information label
        sensor_name = anomaly_info.get('sensor_name', 'Unknown')
        count = anomaly_info.get('count', 0)
        lower_bound = anomaly_info.get('global_lower_bound', 'N/A')
        upper_bound = anomaly_info.get('global_upper_bound', 'N/A')
        total_points = anomaly_info.get('total_points', 0)
        percent_anomalies = (count / total_points * 100) if total_points > 0 else 0
        
        info_text = (
            f"<h3>Anomalies Detected in {sensor_name} Sensor</h3>"
            f"<p>Total Anomalies: {count} </p>"
            f"<p>Total Anomalies: {count} out of {total_points} data points ({percent_anomalies:.2f}%)</p>"
            f"<p>Anomaly Thresholds:</p>"
            f"<ul>"
            f"<li>Lower Bound: {lower_bound:.2f}</li>"
            f"<li>Upper Bound: {upper_bound:.2f}</li>"
            f"</ul>"
            "<p>Choose how to handle these anomalies:</p>"
        )

        self.info_label = QtWidgets.QLabel(info_text)
        self.info_label.setWordWrap(True)
        self.layout.addWidget(self.info_label)
        
        # Create table to display anomalies
        self.table = QtWidgets.QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(["Timestamp", "Value"])
        self.table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.layout.addWidget(self.table)
        
        # Fill table with anomaly clean_data
        outliers = anomaly_info.get('values', pd.Series())

        #Ensure outliers index is datetime
        if len(outliers) > 0:
            self.table.setRowCount(len(outliers))
            
            #Process each outlier
            for i, (timestamp, value) in enumerate(outliers.items()):
                    #Handle timestamp formatting
                    if isinstance(timestamp, (pd.Timestamp, datetime.datetime)):
                        time_str = timestamp.strftime('%Y-%m-%d %H:%M:%S')
                    else:
                        #Try to convert to datetime if not already
                        try:
                            timestamp = pd.to_datetime(timestamp)
                            time_str = timestamp.strftime('%Y-%m-%d %H:%M:%S')
                        except:
                            #If all else fails, use string representation
                            time_str = str(timestamp)

                    #Create and add table items
                    time_item = QtWidgets.QTableWidgetItem(time_str)
                    value_item = QtWidgets.QTableWidgetItem(f"{value:.2f}")
                    self.table.setItem(i, 0, time_item)
                    self.table.setItem(i, 1, value_item)
        else:
            self.table.setRowCount(0)

        
        # Button group
        self.button_box = QtWidgets.QHBoxLayout()
        
        # Create options
        self.remove_button = QtWidgets.QPushButton("Remove Outliers")
        self.ignore_button = QtWidgets.QPushButton("Ignore Outliers")
        self.view_button = QtWidgets.QPushButton("View Outliers")
        
        self.button_box.addWidget(self.remove_button)
        self.button_box.addWidget(self.ignore_button)
        self.button_box.addWidget(self.view_button)
        self.layout.addLayout(self.button_box)
        
        # Connect buttons to actions
        self.remove_button.clicked.connect(self.accept_remove)
        self.ignore_button.clicked.connect(self.accept_ignore)
        self.view_button.clicked.connect(self.accept_view)
        
        # Result attribute to track user's choice
        self.result = "cancel"
        
    def accept_remove(self):
        self.result = "remove"
        self.accept()
        
    def accept_ignore(self):
        self.result = "ignore"
        self.accept()
    
    def accept_view(self):
        self.result = "view"
        self.accept()

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")

        #Horizontal layour for controls
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")

        #Theme selection
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)

        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox.setObjectName("comboBox")
        self.horizontalLayout.addWidget(self.comboBox)

        #File open button
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setObjectName("pushButton")
        self.horizontalLayout.addWidget(self.pushButton)

        #Spacer item to space out widgets to the left
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)

        #Vertical layout for the plot
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(self.spacerItem1)
        self.gridLayout.addLayout(self.verticalLayout, 1, 0, 1, 1)

        MainWindow.setCentralWidget(self.centralwidget)

        #Menu bar
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)

        #Status bar
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        #Actions
        self.actionOpen_CSV = QtWidgets.QAction(MainWindow)
        self.actionOpen_CSV.setObjectName("actionOpen_CSV")
        self.actionExit = QtWidgets.QAction(MainWindow)
        self.actionExit.setObjectName("actionExit")
        self.menuFile.addAction(self.actionOpen_CSV)
        self.menuFile.addAction(self.actionExit)
        self.menubar.addAction(self.menuFile.menuAction())

        #Start time selection
        self.startTimeLabel = QtWidgets.QLabel(self.centralwidget)
        self.startTimeLabel.setText("Start Time:")
        self.horizontalLayout.addWidget(self.startTimeLabel)

        self.startTimeEdit = QDateTimeEdit(self.centralwidget)
        self.startTimeEdit.setCalendarPopup(True)
        self.horizontalLayout.addWidget(self.startTimeEdit)

        #End time selection
        self.endTimeLabel = QtWidgets.QLabel(self.centralwidget)
        self.endTimeLabel.setText("End time:")
        self.horizontalLayout.addWidget(self.endTimeLabel)

        self.endTimeEdit = QDateTimeEdit(self.centralwidget)
        self.endTimeEdit.setCalendarPopup(True)
        self.horizontalLayout.addWidget(self.endTimeEdit)

        #Plot type selection
        self.plotTypeLabel = QtWidgets.QLabel(self.centralwidget)
        self.plotTypeLabel.setObjectName("plotTypeLabel")
        self.plotTypeLabel.setText("Plot Type:")
        self.horizontalLayout.addWidget(self.plotTypeLabel)

        self.plotTypeComboBox = QtWidgets.QComboBox(self.centralwidget)
        self.plotTypeComboBox.setObjectName("plotTypeComboBox")
        self.plotTypeComboBox.addItems(["Line Graph", "Bar Graph", "Histogram", "Box Plot","Heat Map"])
        self.horizontalLayout.addWidget(self.plotTypeComboBox)

        #Nake Create Project button and put it on GUI
        self.createProB = QtWidgets.QPushButton(self.centralwidget)
        self.createProB.setObjectName("createProB")
        self.createProB.setText("Create Project")
        self.horizontalLayout.addWidget(self.createProB)

        #Get img file button
        self.getIMGButton = QtWidgets.QPushButton(self.centralwidget)
        self.getIMGButton.setObjectName("getIMGButton")
        self.getIMGButton.setText("Upload Image")
        self.horizontalLayout.addWidget(self.getIMGButton)


        #Make Save Project button and put it on GUI
        self.saveProB = QtWidgets.QPushButton(self.centralwidget)
        self.saveProB.setObjectName("saveProB")
        self.saveProB.setText("Save Project")
        self.horizontalLayout.addWidget(self.saveProB)

        #Make Load Project button and put it on GUI
        self.loadProB = QtWidgets.QPushButton(self.centralwidget)
        self.loadProB.setObjectName("loadProB")
        self.loadProB.setText("Load Project")
        self.horizontalLayout.addWidget(self.loadProB)

        #Make Clear Data button and put it on GUI
        self.clearDataB = QtWidgets.QPushButton(self.centralwidget)
        self.clearDataB.setObjectName("clearDataB")
        self.clearDataB.setText("Clear Data")
        self.horizontalLayout.addWidget(self.clearDataB)


        #Setting up file name var, canvas, dataframe and toolbar
        self.filenames = ''
        self.imgfile =''
        self.filenames =''
        self.canv = MatplotlibCanvas(self)
        self.df = pd.DataFrame()
        self.toolbar = Navi(self.canv,self.centralwidget)
        self.horizontalLayout.addWidget(self.toolbar)

        self.ignoredAnomalyColumns = set() #Track columns that have had anomalies ignored
        self.cleanedAnomalyColumns = set() #Initialize a set to track cleaned column

        self.anomaly_data_by_column = {} #Will store detected anomalies per sensor

        #Create a dock widget for statistics
        self.statsDockWidget = QDockWidget("Statistics Panel", MainWindow)
        self.statsDockWidget.setFeatures(
            QDockWidget.DockWidgetMovable |
            QDockWidget.DockWidgetFloatable |
            QDockWidget.DockWidgetClosable
        )
        MainWindow.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.statsDockWidget)

        #Create a tab widget for statistics
        self.statsTabWidget = QTabWidget()
        self.statsDockWidget.setWidget(self.statsTabWidget)
        
        #Themes for plotting -- make sure that all of the themes are installed locally otherwise
        #will cause crashes when selected
        self.themes = ['bmh', 'classic', 'dark_background',
                       'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-bright',
                       'seaborn-colorblind', 'seaborn-dark-palette', 'seaborn-dark',
                       'seaborn-darkgrid', 'seaborn-deep', 'seaborn-muted', 'seaborn-notebook',
                       'seaborn-paper', 'seaborn-pastel', 'seaborn-poster', 'seaborn-talk',
                       'seaborn-ticks', 'seaborn-white', 'seaborn-whitegrid', 'seaborn',
                       'Solarize_Light2', 'tableau-colorblind10']

        self.comboBox.addItems(self.themes)

        #Connect signals and slots
        self.pushButton.clicked.connect(self.getFileCSV)
        self.createProB.clicked.connect(self.createP)
        self.saveProB.clicked.connect(self.saveP)
        self.loadProB.clicked.connect(self.loadP)
        self.clearDataB.clicked.connect(self.clearD)
        self.getIMGButton.clicked.connect(self.getFileIMG)


        self.comboBox.currentIndexChanged['QString'].connect(self.update) #For changing theme comboBox
        self.plotTypeComboBox.currentIndexChanged.connect(self.update) #For changing plot type
        self.startTimeEdit.dateTimeChanged.connect(self.update) #For changing time ranges of graph
        self.endTimeEdit.dateTimeChanged.connect(self.update)

        #Finalize UI
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def createP(self):
        #A dialog box is opened and the user is propmted to select a project folder
        f =QFileDialog.getExistingDirectory(None,"Select Project Folder")
        #The project folder directory stored above is saved into a dictory which uses the directory as a key
        #and the files saved in that directory as a path. This will later be stored in a json file
        if f:
            self.pFold = f
            self.pData ={
                "pf":self.pFold, "files":[]}
        else:
            return
        #Creates a subfolder in the main project folder called datafiles which will store the copied CSV files that are uploaded to the project.
        #It will not be created if there already exists one
        self.dataF = os.path.join(self.pFold,"datafiles")
        os.makedirs(self.dataF,exist_ok =True)
        print(f"Project has been made: {self.pFold}")

    def saveP(self):
        #Makes sure that a project has be created
        if not hasattr(self,"pFold") or not self.pFold:
            print("There isn't a project folder to select")
            return
        #Makes sure the datafile subfolder has been made
        self.dataF = os.path.join(self.pFold,"clean_data")
        os.makedirs(self.dataF,exist_ok =True)



        #List is made for copied files and the loop puts each csv file into datafile folder
        localF = []
        for f in self.filenames:
            try:
                #Creates destination path for copied files and copies the files into destination (datafile folder)
                projPath = os.path.join(self.dataF, os.path.basename(f))
                shutil.copy2(f,projPath)
                #File names are added to list
                localF.append(os.path.basename(f))
            except Exception as e:
                print(f"Error copying file {f}: {e}")

        #List is used to update list and stores file paths into json file
        self.pData["files"] =localF
        pf = os.path.join(self.pFold,"proj.json")
        with open(pf,"w") as i:
            json.dump(self.pData,i,indent = 4)

        print(f"Project saved to {pf}")

    def loadP(self):
        #Prompt user to select file(json project file)
        file,_ = QFileDialog.getOpenFileName(filter = "Project Files (*.json)")
        #If a file is not selected a meesge will show and exit the prompy
        if not file:
            print("No Project Selected")
            return
        #Parses and read json file
        try:
            with open(file,"r") as i:
                self.pData = json.load(i)
            #Gets file paths from json
            self.pFold =self.pData.get("pf","")
            self.dataF = os.path.join(self.pFold, "clean_data")
            os.makedirs(self.dataF, exist_ok=True)
            self.filenames = [os.path.join(self.dataF, f) for f in self.pData.get("files", [])]


            if not self.filenames:
                print("No files found")

            self.readData()
            self.update(self.themes[0])

        except Exception as e:
            print(f"Error loading in project: {e}")

    def clearD(self):
        self.df =pd.DataFrame()
        self.filenames = []
        #Reset anomaly handling state
        if hasattr(self, 'ignore_anomalies'):
            delattr(self, 'ignore_anomalies')
        #Reset column state trackers
        self.cleanedAnomalyColumns = set()  
        self.ignoredAnomalyColumns = set() 
        self.update(self.themes[0])
        print("Data has been cleared")

    def update(self,v=None):
        #If v is a QDateTime object (from dateTimeChanged signal) or int(PlotTypeComboBox), ignore it for error reasons
        if isinstance(v, QtCore.QDateTime) | isinstance(v, int):
            v = self.comboBox.currentText() #Use the current theme
        
        print("V from CB: ", v)
        plt.clf()
        plt.style.use(v)

        try:
            self.horizontalLayout.removeWidget(self.toolbar)
            self.verticalLayout.removeWidget(self.canv)

            #Remove spacerItem1 if it exists
            if hasattr(self, 'spacerItem1'):
                self.verticalLayout.removeItem(self.spacerItem1)

            sip.delete(self.toolbar)
            sip.delete(self.canv)
            self.toolbar = None
            self.canv = None

        except Exception as e:
            print(e)
            pass
        
        #Create new canvas and toolbar
        self.canv = MatplotlibCanvas(self)
        self.toolbar = Navi(self.canv,self.centralwidget)

        #Add spacerItem1 if it doesn't exist
        if not hasattr(self, 'spacerItem1'):
            self.spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
            self.verticalLayout.addWidget(self.canv)
        
        #Rebuild layout
        self.horizontalLayout.addWidget(self.toolbar)
        self.verticalLayout.addWidget(self.canv)

        #Clear the axes
        self.canv.axes.cla()
    
        sensors_to_show_anomalies = set()
        if not self.df.empty:
            try: 
                #Process anomaly dialogs if anomalies were found
                #Using previously detected anomalies stored in anomaly_data_by_column
                for sensor_col, anomaly_info in self.anomaly_data_by_column.items():
                    #Skip if sensor's anomalies have been previously ignored or cleaned
                    if sensor_col in self.ignoredAnomalyColumns or sensor_col in self.cleanedAnomalyColumns:
                        continue
                    
                    dialog = AnomalyDialog(MainWindow, anomaly_info)
                    result = dialog.exec_()

                    if result == QtWidgets.QDialog.Accepted:
                        if dialog.result == "remove":
                            # Remove the outliers from the dataframe by setting to NaN
                            outlier_indices = [idx for idx in anomaly_info['values'].index 
                                              if idx in self.df.index]
                            
                            if outlier_indices:  # Only proceed if we have valid indices
                                self.df.loc[outlier_indices, sensor_col] = None
                                #Interpolate only the NaN values just created
                                self.df[sensor_col] = self.df[sensor_col].interpolate(method='linear')
                                 #Mark as cleaned
                                self.cleanedAnomalyColumns.add(sensor_col)
                            
                        elif dialog.result == "ignore":
                            self.ignoredAnomalyColumns.add(sensor_col)  #Add sensor to the ignored sensors set 
                        elif dialog.result == "view":
                            sensors_to_show_anomalies.add(sensor_col)

                #Update statistics
                self.updateStatistics()

                #Get plot type
                plotType = self.plotTypeComboBox.currentText()
                #Get filtered clean_data based on selected time range
                startTime = self.startTimeEdit.dateTime().toPyDateTime()
                endTime = self.endTimeEdit.dateTime().toPyDateTime()

                #Ensure the DataFrame index is datetime
                if not isinstance(self.df.index, pd.DatetimeIndex):
                    self.df.index = pd.to_datetime(self.df.index)

                #Compare it to the original dateTime detected when importing 
                if startTime < self.df.index.min():
                    startTime = self.df.index.min()
                    raise Exception("Start time cannot be before the original start time!")
                elif endTime > self.df.index.max():
                    endTime = self.df.index.max()
                    raise Exception("End time cannot be after original end time!")
            
                filtered_df = self.df[(self.df.index >= startTime) & (self.df.index <= endTime)]
                
                if plotType == "Line Graph":
                    #First plot all clean_data points regardless of anomaly status
                    for c in filtered_df.columns:
                        if not filtered_df[c].empty:
                            self.canv.axes.plot(filtered_df.index, filtered_df[c], label = c)

                    #Plot anomalies if requested to view them
                    for c in sensors_to_show_anomalies:
                        if c in self.anomaly_data_by_column:
                            outliers = self.anomaly_data_by_column[c]['values']
                            # Plot outliers as red dots
                            if not outliers.empty:
                                try:
                                    #Ensure values are within the time range
                                    valid_outliers = outliers[(outliers.index >= startTime) & (outliers.index <= endTime)]
                                    if not valid_outliers.empty:
                                        # Debug print to verify timestamps
                                        print(f"Plotting outliers for {c}:")
                                        print(f"First few timestamps: {valid_outliers.index[:5]}")
                                        self.canv.axes.scatter(valid_outliers.index, valid_outliers.values, color='red', 
                                                      s=5, label=f"{c} outliers", zorder=3) 
                                    else:
                                        print(f"No valid outliers in selected time range for {c}")  
                                except Exception as e:
                                    print(f"Error plotting outliers for {c}:{e}")
                
                    #Configure plot
                    self.canv.axes.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%Y-%m-%d'))
                    self.canv.axes.xaxis.set_major_locator(matplotlib.dates.AutoDateLocator())
                    plt.setp(self.canv.axes.get_xticklabels(), rotation=45, ha='right')
                    legend = self.canv.axes.legend()
                    legend.set_draggable(True)
                    self.canv.axes.set_xlabel('Date-Time')
                    self.canv.axes.set_ylabel('Measured Temperature(°C)')
                    self.canv.axes.set_title('Temperature in Cave Over Time')
                
                elif plotType == "Bar Graph":
                    try:
                        # For bar graphs, resample the data to a suitable frequency
                        # First ensure we have a proper datetime index
                        if not isinstance(filtered_df.index, pd.DatetimeIndex):
                            filtered_df.index = pd.to_datetime(filtered_df.index)

                        # Determine appropriate frequency based on date range
                        date_range = (filtered_df.index.max() - filtered_df.index.min()).total_seconds()
                        
                        if date_range > 60*60*24*30:  # More than a month
                            freq = 'W'  # Weekly
                            freq_label = 'Weekly'
                        elif date_range > 60*60*24*7:  # More than a week
                            freq = 'D'  # Daily
                            freq_label = 'Daily'
                        elif date_range > 60*60*24:  # More than a day
                            freq = '6H'  # 6-hourly
                            freq_label = '6-Hourly'
                        else:
                            freq = 'H'  # Hourly
                            freq_label = 'Hourly'

                        agg_method = "min"
                       
                        # Apply aggregation based on selected method
                        if agg_method == "mean":
                            agg_df = filtered_df.resample(freq).mean()
                        elif agg_method == "median":
                            agg_df = filtered_df.resample(freq).median()
                        elif agg_method == "min":
                            agg_df = filtered_df.resample(freq).min()
                        elif agg_method == "max":
                            agg_df = filtered_df.resample(freq).max()
                        elif agg_method == "sum":
                            agg_df = filtered_df.resample(freq).sum()
                        elif agg_method == "count":
                            agg_df = filtered_df.resample(freq).count()
                        else:
                            # Default to mean
                            agg_df = filtered_df.resample(freq).mean()
                        # Calculate bar width based on number of columns
                        num_cols = len(agg_df.columns)
                        width = 0.8 / num_cols if num_cols > 0 else 0.8
                        
                        # Convert datetime index to numerical values for plotting
                        dates_num = matplotlib.dates.date2num(agg_df.index)
                        
                        # Plot each column as a separate bar series
                        for i, col in enumerate(agg_df.columns):
                            # Calculate position for this set of bars
                            pos = dates_num + (i * width)
                            self.canv.axes.bar(pos, agg_df[col], width=width, label=col)
                        
                        # Configure plot
                        self.canv.axes.set_xlabel('Time Period')
                        self.canv.axes.set_ylabel(f'{agg_method.capitalize()} Temperature (°C)')
                        self.canv.axes.set_title(f'{freq_label} {agg_method.capitalize()} Temperature')
                        
                        # Format x-axis as dates
                        self.canv.axes.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%Y-%m-%d'))
                        self.canv.axes.xaxis.set_major_locator(matplotlib.dates.AutoDateLocator())
                        plt.setp(self.canv.axes.get_xticklabels(), rotation=45, ha='right')
                        
                        # Add legend
                        if num_cols > 0:
                            legend = self.canv.axes.legend()
                            legend.set_draggable(True)
                    
                    except Exception as e:
                        print(f"Error in bar graph plotting: {e}")
                        raise

                elif plotType == "Histogram":
                    # We'll create a histogram for each column with transparency
                    bins = 20  # Number of bins
                    
                    for col in filtered_df.columns:
                        # Remove NaN values for histogram
                        clean_data = filtered_df[col].dropna()
                        
                        # Only create histogram if we have clean_data
                        if len(clean_data) > 0:
                            self.canv.axes.hist(clean_data, bins=bins, alpha=0.7, label=col)
                    
                    # Configure plot
                    self.canv.axes.set_xlabel('Temperature (°C)')
                    self.canv.axes.set_ylabel('Frequency')
                    self.canv.axes.set_title('Temperature Distribution')
                    legend = self.canv.axes.legend()
                    legend.set_draggable(True)
                    
                elif plotType == "Box Plot":
                    # For box plots, we need to prepare the clean_data differently
                    # We'll create a list of clean_data for each column
                    clean_data = []
                    labels = []
                    
                    for col in filtered_df.columns:
                        # Only add column if it has non-NaN values
                        if not filtered_df[col].isna().all():
                            clean_data.append(filtered_df[col].dropna())
                            labels.append(col)
                    
                    # Create box plot
                    if clean_data:
                        self.canv.axes.boxplot(clean_data, labels=labels, patch_artist=True)
                        
                        # Configure plot
                        self.canv.axes.set_xlabel('Sensor')
                        self.canv.axes.set_ylabel('Temperature (°C)')
                        self.canv.axes.set_title('Temperature Distribution by Sensor')
                        self.canv.axes.grid(True, linestyle='--', alpha=0.7)

                self.canv.draw()
                self.canv.figure.tight_layout()

            except Exception as e:
                print("Plotting error:", e)
                traceback.print_exc()

    def updateStatistics(self):
        #Clear existing tabs
        self.statsTabWidget.clear()
        
        #Get filtered clean_data based on selected time range
        startTime = self.startTimeEdit.dateTime().toPyDateTime()
        endTime = self.endTimeEdit.dateTime().toPyDateTime()
        filtered_df = self.df[(self.df.index >= startTime) & (self.df.index <= endTime)]

        #Add a tab for each sensor
        for column in filtered_df.columns:
            if column.startswith("Temperature_"):
                sensorName = column.replace("Temperature_", "")
                statsText = self.calculateStatistics(filtered_df[column])

                #Create a QTextEdit for the statistics
                textEdit = QTextEdit()
                textEdit.setReadOnly(True)
                textEdit.setText(statsText)
                
                #Add the QTextEdit to a new tab
                self.statsTabWidget.addTab(textEdit, sensorName)

    def detectAnomalies(self, data):
        """
        Enhanced anomaly detection with better spike handling and duplicate management
        """
        clean_data = data.dropna()
        sensor_name = clean_data.name.replace("Temperature_", "") if hasattr(clean_data, 'name') else "Unknown"

        if clean_data.empty:
            return {
                "count": 0,
                "values": pd.Series(dtype=float),
                "global_lower_bound": None,
                "global_upper_bound": None,
                "total_points": 0,
                "sensor_name": sensor_name
            }

        # Calculate quartiles and IQR
        Q1 = clean_data.quantile(0.25, interpolation='midpoint')
        Q3 = clean_data.quantile(0.75, interpolation='midpoint')
        IQR = Q3 - Q1

        # Identify IQR outliers
        threshold = 1.5
        lower_bound = Q1 - threshold * IQR
        upper_bound = Q3 + threshold * IQR
        iqr_outliers = clean_data[(clean_data < lower_bound) | (clean_data > upper_bound)]
        
        # Spike detection with adaptive threshold
        diff = clean_data.diff().abs()
        if not diff.empty:
            # Dynamic spike threshold based on rolling window
            rolling_std = diff.rolling(window=10, min_periods=1).std()
            spike_threshold = 3 * rolling_std  # 3 standard deviations
            spike_outliers = clean_data[diff > spike_threshold]
            
            # Combine outliers while preserving important cases
            combined_outliers = pd.concat([iqr_outliers, spike_outliers])
            
            # Smart de-duplication - keep all if they're significant spikes
            if not combined_outliers.empty:
                # Only remove duplicates that aren't significant spikes
                mask = (combined_outliers.index.duplicated(keep='first') & 
                    (diff.loc[combined_outliers.index] < 2 * rolling_std.loc[combined_outliers.index]))
                outliers = combined_outliers[~mask]
            else:
                outliers = combined_outliers
        else:
            outliers = iqr_outliers

        return {
            "count": len(outliers),
            "values": outliers.sort_values(),
            "global_lower_bound": lower_bound,
            "global_upper_bound": upper_bound,
            "total_points": len(clean_data),
            "sensor_name": sensor_name,
            "iqr_outliers": len(iqr_outliers),
            "spike_outliers": len(outliers) - len(iqr_outliers)
        }  
  
    def calculateStatistics(self, clean_data):
        try:
            # Ensure numeric clean_data
            numeric_data = pd.to_numeric(clean_data, errors='coerce')
            valid_data = numeric_data[py.isfinite(numeric_data)]
            
            if len(valid_data) == 0:
                return "No valid numeric clean_data"
            
            stats = {
                "Min": float(py.nanmin(valid_data)),
                "Max": float(py.nanmax(valid_data)),
                "Mean": float(py.nanmean(valid_data)),
                "Median": float(py.nanmedian(valid_data)),
                "Std Dev": float(py.nanstd(valid_data)),
                "Count": int(len(valid_data))
            }
            
            return "\n".join([f"{k}: {v:.2f}" if k != "Count" else f"{k}: {v}" 
                            for k, v in stats.items()])
        
        except Exception as e:
            return f"Statistics error: {str(e)}"

    def getFileCSV(self):
        #Will get file address of csv file and read it
        files,_ = QFileDialog.getOpenFileNames(filter="CSV Files (*.csv)")
        if files:
            self.filenames = files
            print("Files :", self.filenames)
            self.readData()
        else:
            print("No files selected.")

    def getFileIMG(self):
        #Will get file address of img file and read it
        file,_ = QFileDialog.getOpenFileName(filter = "Images (*.png *.xpm *.jpg)");
        if file:
            self.imgfile = file
            print("Files :", self.imgfile)
        else:
            print("No files selected.")

    def readData(self):
    
        """
        Takes csv file(s) and returns a dataframe with index as datetime and datatype as columns.
        
        """
        self.anomaly_data_by_column = {}
        merged_dfs = []

        #First pass: Read and preprocess all files
        for file in self.filenames:
            try:
                sensor_name = os.path.basename(file).split('.')[0]
                temp_col_name = f"Temperature_{sensor_name}"

                try:
                    #reads the csv files, only the Date time and temperature column, and saves it into a dataframe
                    single_df = pd.read_csv(
                        file,encoding = 'utf-8',
                        usecols=['Date-Time (EST)', 'Temperature   (°C)']
                        )
                except ValueError as e:
                    print(f"Missing required columns in {file}: {e}")
                    continue

                #Validate data
                if single_df.empty:
                    print(f"No data in {file}")
                    continue
                
                #formats the date time column so that it is readable by matplotlib
                single_df["Date-Time (EST)"] = pd.to_datetime(single_df["Date-Time (EST)"], 
                                                             format="%m/%d/%Y %H:%M:%S", errors="coerce")
                # Drop rows with invalid dates
                single_df = single_df.dropna(subset=["Date-Time (EST)"])
                
                # Rename temperature column to include sensor name
                single_df = single_df.rename(
                    columns={'Temperature   (°C)': temp_col_name}
                    )
                
                #Set datetime as index
                single_df = single_df.set_index("Date-Time (EST)")

                #Resample to every two minutes for consistency
                single_df = single_df.resample('2min').mean().interpolate(method='linear')
                
                #Detect anomalies
                anomaly_info = self.detectAnomalies(single_df[temp_col_name])
                if anomaly_info["count"] > 0:
                    self.anomaly_data_by_column[temp_col_name] = anomaly_info

                # Append to list for merging
                merged_dfs.append(single_df)

            except Exception as e:
                print(f"Error processing {file}: {str(e)}")
                traceback.print_exc()
                continue

        # Merge the dataframes
        if merged_dfs:
            # Start with first dataframe
            if len(merged_dfs) == 1:
                # If only one dataframe, no need to merge
                self.df = merged_dfs[0]
            else:
                self.df = merged_dfs[0]
                for df in merged_dfs[1:]:
                    self.df = pd.concat(merged_dfs, axis=1)
    
            # Set datetime index and sort
            self.df.index = pd.to_datetime(self.df.index)
            self.df = self.df.sort_index()
            
            #Drop rows that have any missing values for calculation reasons
            self.df = self.df.dropna(axis=0)

            #Don't have to interpolate since the removed values are on edges

            # Now interpolate after merging
            #for col in self.df.columns:
                # First fill NaN with linear interpolation
                #self.df[col] = self.df[col].interpolate(method='linear')
                #Then forward/backward fill any remaining NaNs at edges
                #self.df[col] = self.df[col].ffill().bfill()

            # Update time range controls
            self.startTimeEdit.blockSignals(True)
            self.endTimeEdit.blockSignals(True)

            #Set default time range
            self.startTimeEdit.setDateTime(QtCore.QDateTime(self.df.index.min()))
            self.endTimeEdit.setDateTime(QtCore.QDateTime(self.df.index.max()))

            self.startTimeEdit.blockSignals(False)
            self.endTimeEdit.blockSignals(False)

            self.updateStatistics()
            self.update(self.themes[0])
        else:
            print("Data not valid")

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label.setText(_translate("MainWindow", "Select Theme"))
        self.pushButton.setText(_translate("MainWindow", "Open"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.actionOpen_CSV.setText(_translate("MainWindow", "Open CSV"))
        self.actionExit.setText(_translate("MainWindow", "Exit"))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

#####
#A lot of the code is hardcoded just for testing sake, but I'll change it
#####

from PyQt5 import QtCore, QtGui, QtWidgets
import matplotlib
import matplotlib.pyplot as plt
matplotlib.use('Qt5Agg')
from PyQt5.QtWidgets import QFileDialog, QDateTimeEdit, QDockWidget, QTabWidget, QTextEdit
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg, NavigationToolbar2QT as Navi
from matplotlib.figure import Figure
import seaborn as sns
import pandas as pd
import numpy as py
import sip # can be installed : pip install sip
import os
import json
import shutil

#Canvas class
class MatplotlibCanvas(FigureCanvasQTAgg):
    def __init__(self,parent=None,width=5, height = 5, dpi = 120):
        f = Figure(figsize = (width,height),dpi = dpi)
        self.axes= f.add_subplot(111)
        super(MatplotlibCanvas,self).__init__(f)
        f.tight_layout()

class AnomalyDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, anomaly_info=None):
        super(AnomalyDialog, self).__init__(parent)
        self.setWindowTitle("Anomaly Detection")
        self.resize(500, 300)
        
        # Main layout
        self.layout = QtWidgets.QVBoxLayout(self)
        
        # Create information label
        sensor_name = anomaly_info.get('sensor_name', 'Unknown')
        count = anomaly_info.get('count', 0)
        
        self.info_label = QtWidgets.QLabel(
            f"<h3>Anomalies Detected in {sensor_name}</h3>"
            f"<p>Found {count} data points outside the expected range.</p>"
            "<p>Outliers can affect statistical analysis and visualization.</p>"
        )
        self.info_label.setWordWrap(True)
        self.layout.addWidget(self.info_label)
        
        # Create table to display anomalies
        self.table = QtWidgets.QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(["Timestamp", "Value"])
        self.table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.layout.addWidget(self.table)
        
        # Fill table with anomaly data
        outliers = anomaly_info.get('values', pd.Series())
        self.table.setRowCount(len(outliers))
        
        for i, (timestamp, value) in enumerate(outliers.items()):
            time_item = QtWidgets.QTableWidgetItem(timestamp.strftime('%Y-%m-%d %H:%M:%S'))
            value_item = QtWidgets.QTableWidgetItem(f"{value:.2f}")
            self.table.setItem(i, 0, time_item)
            self.table.setItem(i, 1, value_item)
        
        # Button group
        self.button_box = QtWidgets.QHBoxLayout()
        
        # Create options
        self.remove_button = QtWidgets.QPushButton("Remove Outliers")
        self.ignore_button = QtWidgets.QPushButton("Ignore Outliers")
        self.cancel_button = QtWidgets.QPushButton("Cancel")
        
        self.button_box.addWidget(self.remove_button)
        self.button_box.addWidget(self.ignore_button)
        self.button_box.addWidget(self.cancel_button)
        self.layout.addLayout(self.button_box)
        
        # Connect buttons to actions
        self.remove_button.clicked.connect(self.accept_remove)
        self.ignore_button.clicked.connect(self.accept_ignore)
        self.cancel_button.clicked.connect(self.reject)
        
        # Result attribute to track user's choice
        self.result = "cancel"
        
    def accept_remove(self):
        self.result = "remove"
        self.accept()
        
    def accept_ignore(self):
        self.result = "ignore"
        self.accept()

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")

        #Horizontal layour for controls
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")

        #Theme selection
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)

        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox.setObjectName("comboBox")
        self.horizontalLayout.addWidget(self.comboBox)

        #File open button
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setObjectName("pushButton")
        self.horizontalLayout.addWidget(self.pushButton)

        #Spacer item to space out widgets to the left
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)

        #Vertical layout for the plot
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(self.spacerItem1)
        self.gridLayout.addLayout(self.verticalLayout, 1, 0, 1, 1)

        MainWindow.setCentralWidget(self.centralwidget)

        #Menu bar
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)

        #Status bar
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        #Actions
        self.actionOpen_CSV = QtWidgets.QAction(MainWindow)
        self.actionOpen_CSV.setObjectName("actionOpen_CSV")
        self.actionExit = QtWidgets.QAction(MainWindow)
        self.actionExit.setObjectName("actionExit")
        self.menuFile.addAction(self.actionOpen_CSV)
        self.menuFile.addAction(self.actionExit)
        self.menubar.addAction(self.menuFile.menuAction())

        #Start time selection
        self.startTimeLabel = QtWidgets.QLabel(self.centralwidget)
        self.startTimeLabel.setText("Start Time:")
        self.horizontalLayout.addWidget(self.startTimeLabel)

        self.startTimeEdit = QDateTimeEdit(self.centralwidget)
        self.startTimeEdit.setCalendarPopup(True)
        self.horizontalLayout.addWidget(self.startTimeEdit)

        #End time selection
        self.endTimeLabel = QtWidgets.QLabel(self.centralwidget)
        self.endTimeLabel.setText("End time:")
        self.horizontalLayout.addWidget(self.endTimeLabel)

        self.endTimeEdit = QDateTimeEdit(self.centralwidget)
        self.endTimeEdit.setCalendarPopup(True)
        self.horizontalLayout.addWidget(self.endTimeEdit)

        #Plot type selection
        self.plotTypeLabel = QtWidgets.QLabel(self.centralwidget)
        self.plotTypeLabel.setObjectName("plotTypeLabel")
        self.plotTypeLabel.setText("Plot Type:")
        self.horizontalLayout.addWidget(self.plotTypeLabel)

        self.plotTypeComboBox = QtWidgets.QComboBox(self.centralwidget)
        self.plotTypeComboBox.setObjectName("plotTypeComboBox")
        self.plotTypeComboBox.addItems(["Line Graph", "Bar Graph", "Histogram", "Box Plot"])
        self.horizontalLayout.addWidget(self.plotTypeComboBox)

        #Nake Create Project button and put it on GUI
        self.createProB = QtWidgets.QPushButton(self.centralwidget)
        self.createProB.setObjectName("createProB")
        self.createProB.setText("Create Project")
        self.horizontalLayout.addWidget(self.createProB)

        #Make Save Project button and put it on GUI
        self.saveProB = QtWidgets.QPushButton(self.centralwidget)
        self.saveProB.setObjectName("saveProB")
        self.saveProB.setText("Save Project")
        self.horizontalLayout.addWidget(self.saveProB)

        #Make Load Project button and put it on GUI
        self.loadProB = QtWidgets.QPushButton(self.centralwidget)
        self.loadProB.setObjectName("loadProB")
        self.loadProB.setText("Load Project")
        self.horizontalLayout.addWidget(self.loadProB)

        #Make Clear Data button and put it on GUI
        self.clearDataB = QtWidgets.QPushButton(self.centralwidget)
        self.clearDataB.setObjectName("clearDataB")
        self.clearDataB.setText("Clear Data")
        self.horizontalLayout.addWidget(self.clearDataB)


        #Setting up file name var, canvas, dataframe and toolbar
        self.filenames =''
        self.canv = MatplotlibCanvas(self)
        self.df = pd.DataFrame()
        self.toolbar = Navi(self.canv,self.centralwidget)
        self.horizontalLayout.addWidget(self.toolbar)


        #Create a dock widget for statistics
        self.statsDockWidget = QDockWidget("Statistics Panel", MainWindow)
        self.statsDockWidget.setFeatures(
            QDockWidget.DockWidgetMovable |
            QDockWidget.DockWidgetFloatable |
            QDockWidget.DockWidgetClosable
        )
        MainWindow.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.statsDockWidget)

        #Create a tab widget for statistics
        self.statsTabWidget = QTabWidget()
        self.statsDockWidget.setWidget(self.statsTabWidget)
        
        #Themes for plotting -- make sure that all of the themes are installed locally otherwise
        #will cause crashes when selected
        self.themes = ['bmh', 'classic', 'dark_background',
                       'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-bright',
                       'seaborn-colorblind', 'seaborn-dark-palette', 'seaborn-dark',
                       'seaborn-darkgrid', 'seaborn-deep', 'seaborn-muted', 'seaborn-notebook',
                       'seaborn-paper', 'seaborn-pastel', 'seaborn-poster', 'seaborn-talk',
                       'seaborn-ticks', 'seaborn-white', 'seaborn-whitegrid', 'seaborn',
                       'Solarize_Light2', 'tableau-colorblind10']

        self.comboBox.addItems(self.themes)

        #Connect signals and slots
        self.pushButton.clicked.connect(self.getFile)
        self.createProB.clicked.connect(self.createP)
        self.saveProB.clicked.connect(self.saveP)
        self.loadProB.clicked.connect(self.loadP)
        self.clearDataB.clicked.connect(self.clearD)

        self.comboBox.currentIndexChanged['QString'].connect(self.update) #For changing theme comboBox
        self.plotTypeComboBox.currentIndexChanged.connect(self.update) #For changing plot type
        self.startTimeEdit.dateTimeChanged.connect(self.update) #For changing time ranges of graph
        self.endTimeEdit.dateTimeChanged.connect(self.update)

        #Finalize UI
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def createP(self):
        #A dialog box is opened and the user is propmted to select a project folder
        f =QFileDialog.getExistingDirectory(None,"Select Project Folder")
        #The project folder directory stored above is saved into a dictory which uses the directory as a key
        #and the files saved in that directory as a path. This will later be stored in a json file
        if f:
            self.pFold = f
            self.pData ={
                "pf":self.pFold, "files":[]}
        else:
            return
        #Creates a subfolder in the main project folder called datafiles which will store the copied CSV files that are uploaded to the project.
        #It will not be created if there already exists one
        self.dataF = os.path.join(self.pFold,"datafiles")
        os.makedirs(self.dataF,exist_ok =True)
        print(f"Project has been made: {self.pFold}")

    def saveP(self):
        #Makes sure that a project has be created
        if not hasattr(self,"pFold") or not self.pFold:
            print("There isn't a project folder to select")
            return
        #Makes sure the datafile subfolder has been made
        self.dataF = os.path.join(self.pFold,"data")
        os.makedirs(self.dataF,exist_ok =True)



        #List is made for copied files and the loop puts each csv file into datafile folder
        localF = []
        for f in self.filenames:
            try:
                #Creates destination path for copied files and copies the files into destination (datafile folder)
                projPath = os.path.join(self.dataF, os.path.basename(f))
                shutil.copy2(f,projPath)
                #File names are added to list
                localF.append(os.path.basename(f))
            except Exception as e:
                print(f"Error copying file {f}: {e}")

        #List is used to update list and stores file paths into json file
        self.pData["files"] =localF
        pf = os.path.join(self.pFold,"proj.json")
        with open(pf,"w") as i:
            json.dump(self.pData,i,indent = 4)

        print(f"Project saved to {pf}")

    def loadP(self):
        #Prompt user to select file(json project file)
        file,_ = QFileDialog.getOpenFileName(filter = "Project Files (*.json)")
        #If a file is not selected a meesge will show and exit the prompy
        if not file:
            print("No Project Selected")
            return
        #Parses and read json file
        try:
            with open(file,"r") as i:
                self.pData = json.load(i)
            #Gets file paths from json
            self.pFold =self.pData.get("pf","")
            self.dataF = os.path.join(self.pFold, "data")
            os.makedirs(self.dataF, exist_ok=True)
            self.filenames = [os.path.join(self.dataF, f) for f in self.pData.get("files", [])]


            if not self.filenames:
                print("No files found")

            self.readData()
            self.update(self.themes[0])

        except Exception as e:
            print(f"Error loading in project: {e}")

    def clearD(self):
        self.df =pd.DataFrame()
        self.filenames = []
        #Reset anomaly handling state
        if hasattr(self, 'ignore_anomalies'):
            delattr(self, 'ignore_anomalies')
        self.update(self.themes[0])
        print("Data has been cleared")

    def update(self,v=None):
        #If v is a QDateTime object (from dateTimeChanged signal), ignore it
        if isinstance(v, QtCore.QDateTime):

            v = self.comboBox.currentText() #Use the current theme
        # If v is an integer (from plotTypeComboBox), use current theme
        elif isinstance(v, int):
            v = self.comboBox.currentText()  # Use the current theme

        print("V from CB: ", v)
        plt.clf()
        plt.style.use(v)
        try:
            self.horizontalLayout.removeWidget(self.toolbar)
            self.verticalLayout.removeWidget(self.canv)

            #Remove spacerItem1 if it exists
            if hasattr(self, 'spacerItem1'):
                self.verticalLayout.removeItem(self.spacerItem1)

            sip.delete(self.toolbar)
            sip.delete(self.canv)
            self.toolbar = None
            self.canv = None

        except Exception as e:
            print(e)
            pass
        
        #Create new canvas and toolbar
        self.canv = MatplotlibCanvas(self)
        self.toolbar = Navi(self.canv,self.centralwidget)

        #Add spacerItem1 if it doesn't exist
        if not hasattr(self, 'spacerItem1'):
            self.spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
            self.verticalLayout.addWidget(self.canv)
        
        #Rebuild layout
        self.horizontalLayout.addWidget(self.toolbar)
        self.verticalLayout.addWidget(self.canv)

        
        self.canv.axes.cla()
        
        if not self.df.empty:
            try:
                #Get filtered data based on selected time range
                startTime = self.startTimeEdit.dateTime().toPyDateTime()
                endTime = self.endTimeEdit.dateTime().toPyDateTime()
                filtered_df = self.df[(self.df.index >= startTime) & (self.df.index <= endTime)]

                # Track if any anomalies were found across all sensors
                anomalies_found = False
                anomalies_by_sensor = {}
                
                # Check for anomalies in each temperature column
                for c in filtered_df.columns:
                    if c.startswith("Temperature_"):
                        # Get outliers using our existing method
                        anomaly_data = self.detectAnomalies(filtered_df[c])
                        if anomaly_data['count'] > 0:
                            anomalies_found = True
                            sensorName = c.replace("Temperature_", "")
                            anomalies_by_sensor[c] = {
                                'sensor_name': sensorName,
                                'count': anomaly_data['count'],
                                'values': anomaly_data['values'],
                                'column': c
                            }
                
                # If anomalies were found and we're not in a state where we're ignoring them
                if anomalies_found and not hasattr(self, 'ignore_anomalies'):
                    # Start with the first sensor that has anomalies
                    for sensor_col, anomaly_info in anomalies_by_sensor.items():
                        dialog = AnomalyDialog(MainWindow, anomaly_info)
                        result = dialog.exec_()
                        
                        if result == QtWidgets.QDialog.Accepted:
                            if dialog.result == "remove":
                                # Remove the outliers from the dataframe
                                outlier_indices = anomaly_info['values'].index
                                self.df.loc[outlier_indices, sensor_col] = None
                                # Interpolate the removed values
                                self.df[sensor_col] = self.df[sensor_col].interpolate(method='linear')
                                # Re-filter the data after modification
                                filtered_df = self.df[(self.df.index >= startTime) & (self.df.index <= endTime)]
                                print(f"Removed {len(outlier_indices)} outliers from {anomaly_info['sensor_name']}")
                            elif dialog.result == "ignore":
                                # Set a flag to ignore anomalies for this session
                                self.ignore_anomalies = True
                                print("Ignoring outliers for this session")
                            break  # Only show dialog for the first sensor with anomalies

                #Update statistics
                self.updateStatistics()

                #Get plot type
                plotType = self.plotTypeComboBox.currentText()

                if plotType == "Line Graph":
                    for c in filtered_df.columns:
                        self.canv.axes.plot(filtered_df.index, filtered_df[c], label = c)
                        
                        # If we're not ignoring anomalies, highlight them
                        if not hasattr(self, 'ignore_anomalies') or not self.ignore_anomalies:
                            # Get outliers using our existing method
                            anomaly_data = self.detectAnomalies(filtered_df[c])
                            outliers = anomaly_data['values']
                            
                            # Plot outliers as red dots
                            if not outliers.empty:
                                self.canv.axes.scatter(outliers.index, outliers.values, color='red', 
                                                      s=50, label=f"{c} outliers", zorder=5)
                    #Configure plot
                    legend = self.canv.axes.legend()
                    legend.set_draggable(True)
                    self.canv.axes.set_xlabel('Date-Time')
                    self.canv.axes.set_ylabel('Measured')
                    self.canv.axes.set_title('Temperature in Cave Over Time')
                
                elif plotType == "Bar Graph":
                    # For bar graphs, we'll need to resample the data to a suitable frequency
                    # since plotting every timestamp would be too crowded
                    
                    # Determine appropriate frequency based on date range
                    date_range = (filtered_df.index.max() - filtered_df.index.min()).total_seconds()
                    
                    if date_range > 60*60*24*30:  # More than a month
                        freq = 'W'  # Weekly
                        freq_label = 'Weekly'
                    elif date_range > 60*60*24*7:  # More than a week
                        freq = 'D'  # Daily
                        freq_label = 'Daily'
                    elif date_range > 60*60*24:  # More than a day
                        freq = '6H'  # 6-hourly
                        freq_label = '6-Hourly'
                    else:
                        freq = 'H'  # Hourly
                        freq_label = 'Hourly'
                    
                    # Resample data
                    resampled_df = filtered_df.resample(freq).mean()
                    
                    # Calculate bar width based on number of columns
                    width = 0.8 / len(resampled_df.columns)
                    
                    # Plot each column as a separate bar series
                    for i, col in enumerate(resampled_df.columns):
                        # Calculate position for this set of bars
                        pos = [j + (i * width) for j in range(len(resampled_df))]
                        self.canv.axes.bar(pos, resampled_df[col], width=width, label=col)
                    
                    # Configure plot
                    self.canv.axes.set_xlabel('Time Period')
                    self.canv.axes.set_ylabel('Average Temperature (°C)')
                    self.canv.axes.set_title(f'{freq_label} Average Temperature')
                    self.canv.axes.set_xticks(range(len(resampled_df)))
                    self.canv.axes.set_xticklabels([d.strftime('%Y-%m-%d') for d in resampled_df.index], rotation=45)
                    legend = self.canv.axes.legend()
                    legend.set_draggable(True)
                    
                elif plotType == "Histogram":
                    # We'll create a histogram for each column with transparency
                    bins = 20  # Number of bins
                    
                    for col in filtered_df.columns:
                        # Remove NaN values for histogram
                        data = filtered_df[col].dropna()
                        
                        # Only create histogram if we have data
                        if len(data) > 0:
                            self.canv.axes.hist(data, bins=bins, alpha=0.7, label=col)
                    
                    # Configure plot
                    self.canv.axes.set_xlabel('Temperature (°C)')
                    self.canv.axes.set_ylabel('Frequency')
                    self.canv.axes.set_title('Temperature Distribution')
                    legend = self.canv.axes.legend()
                    legend.set_draggable(True)
                    
                elif plotType == "Box Plot":
                    # For box plots, we need to prepare the data differently
                    # We'll create a list of data for each column
                    data = []
                    labels = []
                    
                    for col in filtered_df.columns:
                        # Only add column if it has non-NaN values
                        if not filtered_df[col].isna().all():
                            data.append(filtered_df[col].dropna())
                            labels.append(col)
                    
                    # Create box plot
                    if data:
                        self.canv.axes.boxplot(data, labels=labels, patch_artist=True)
                        
                        # Configure plot
                        self.canv.axes.set_xlabel('Sensor')
                        self.canv.axes.set_ylabel('Temperature (°C)')
                        self.canv.axes.set_title('Temperature Distribution by Sensor')
                        self.canv.axes.grid(True, linestyle='--', alpha=0.7)        
                
                self.canv.draw()
                self.canv.figure.tight_layout()
            except Exception as e:
                print("Plotting error:", e)

    def updateStatistics(self):
        #Clear existing tabs
        self.statsTabWidget.clear()
        
        #Get filtered data based on selected time range
        startTime = self.startTimeEdit.dateTime().toPyDateTime()
        endTime = self.endTimeEdit.dateTime().toPyDateTime()
        filtered_df = self.df[(self.df.index >= startTime) & (self.df.index <= endTime)]

        #Add a tab for each sensor
        for column in self.df.columns:
            if column.startswith("Temperature_"):
                sensorName = column.replace("Temperature_", "")
                statsText = self.calculateStatistics(filtered_df[column])

                #Create a QTextEdit for the statistics
                textEdit = QTextEdit()
                textEdit.setReadOnly(True)
                textEdit.setText(statsText)
                
                #Add the QTextEdit to a new tab
                self.statsTabWidget.addTab(textEdit, sensorName)

    def detectAnomalies(self, data):
        # Calculate quartiles and IQR
        Q1 = data.quantile(0.25)
        Q3 = data.quantile(0.75)
        IQR = Q3 - Q1

        # Identify outliers using the 1.5 * IQR rule
        threshold = 1.5
        lower_bound = Q1 - threshold * IQR
        upper_bound = Q3 + threshold * IQR
    
        # Find global outliers
        globalOutliers = data[(data < lower_bound) | (data > upper_bound)]

        #Rolling window detection for local contextual anomalies 
        #windowSize = 24 #For hourly data, 

        #Calculate rolling mean and standard deviation
        #rollingMean = data.rolling(window=windowSize, center=True).mean()
        #rollingStd = data.rolling(window=windowSize, center=True).std()

        #Define how many standard deviations is considered anomalous
        #stdThreshold = 3.0

        #Calculate the upper and lower bounds for local anomalies
        #localLowerBound = rollingMean - stdThreshold * rollingStd
        #localUpperBound = rollingMean +stdThreshold * rollingStd

        #Find local outliers
        #mask = ((data < localLowerBound) | (data > localUpperBound))
        #localOutliers = data[mask]

        #Combine both types of outliers
        #allOutliers = pd.concat([globalOutliers, localOutliers]).drop_duplicates()
    
        return {
            "count": len(globalOutliers),
            "values": globalOutliers,
            "global_lower_bound": lower_bound,
            "global_upper_bound": upper_bound,
        }   

    def calculateStatistics(self, data):
        stats = {
            "Min" : data.min(),
            "Max" : data.max(),
            "Mean" : data.mean(),
            "Median" : data.median(),
            "Standard deviation" : data.std()  
        }

        #Anomaly detection
        anomalies = self.detectAnomalies(data)

        #Create statistics text
        statsText = "\n".join(f"{key}: {value:2F}" for key, value in stats.items())

        # Add anomaly information
        statsText += f"\n\nTotal Outliers: {anomalies['count']}"
        statsText += f"\nGlobal Lower bound: {anomalies['global_lower_bound']:.2f}"
        statsText += f"\nGlobal Upper bound: {anomalies['global_upper_bound']:.2f}"


         # List outlier timestamps if there are any
        if anomalies['count'] > 0:
            statsText += "\n\nOutlier timestamps:"
            for idx, value in anomalies['values'].items():
                statsText += f"\n{idx.strftime('%Y-%m-%d %H:%M:%S')}: {value:.2f}"
    
        return statsText

    def getFile(self):
        #Will get file address of csv file and read it
        files,_ = QFileDialog.getOpenFileNames(filter="CSV Files (*.csv)")
        if files:
            self.filenames = files
            print("Files :", self.filenames)
            self.readData()
        else:
            print("No files selected.")

    def readData(self):
        #Function to read csv data
        #Dictonary for each sensor's dataframe
        eachSensor = {}
        #Loops through each csv file added.(Note: When uploading the CSV files, you have to add them all at once, you can NOT open one csv file at a time.)
        for file in self.filenames:
            try:
                #Gets the file name of file uploaded by parsing the file directory
                sensorN = os.path.basename(file).split('.')[0]
                #reads the csv files, only the Date time and  temperature column, and saves it into a dataframe
                singleDF = pd.read_csv(file,encoding = 'utf-8',usecols=['Date-Time (EST)', 'Temperature   (°C)'])
                #formats the date time column so that it is readable by matplotlib
                singleDF["Date-Time (EST)"] = pd.to_datetime(singleDF["Date-Time (EST)"], format="%m/%d/%Y %H:%M:%S", errors="coerce")
                #Drop rows with no date values
                singleDF.dropna(subset=["Date-Time (EST)"], inplace=True)
                #Rename temp  column to temp_sensorN (sensorN being the file name so name the file accordingly)
                singleDF.rename(columns={'Temperature   (°C)': f'Temperature_{sensorN}'}, inplace=True)
                #Stores the dataframe in dictonary
                eachSensor[sensorN] = singleDF
            except Exception as e:
                print(f"Error in {file}: {e}")

        #Merges the dataframes in the dictonary into one dataframe.
        if eachSensor:
            #Starts with the first dataframe as refrence, then merges the rest of them based on it
            self.df = next(iter(eachSensor.values()))
            for eachSensor,singleDF in list(eachSensor.items())[1:]:
                #Merges them with Datetime as ref
                self.df = pd.merge(self.df, singleDF, on="Date-Time (EST)", how="outer")
            #Sorts by datetime even though it should already be sorted
            self.df.sort_values(by="Date-Time (EST)", inplace=True)
            #Sets datetime as index and if there are missing temp values then inteopate them based on surrounded temps in column
            self.df.set_index("Date-Time (EST)", inplace=True)
            #self.df.dropna(subset=["Date-Time (EST)"], inplace=True)
            self.df.interpolate(method='linear', inplace=True)

            #Blocks signals while updating time range
            self.startTimeEdit.blockSignals(True)
            self.endTimeEdit.blockSignals(True)

            #Set default time range
            self.startTimeEdit.setDateTime(QtCore.QDateTime(self.df.index.min()))
            self.endTimeEdit.setDateTime(QtCore.QDateTime(self.df.index.max()))

            #Unblock signals
            self.startTimeEdit.blockSignals(False)
            self.endTimeEdit.blockSignals(False)

            #Update statistics
            self.updateStatistics()

            #Update plot
            self.update(self.themes[0])
        else:
            print("Data not valid")

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label.setText(_translate("MainWindow", "Select Theme"))
        self.pushButton.setText(_translate("MainWindow", "Open"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.actionOpen_CSV.setText(_translate("MainWindow", "Open CSV"))
        self.actionExit.setText(_translate("MainWindow", "Exit"))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

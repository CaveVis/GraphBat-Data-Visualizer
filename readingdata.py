# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

#####
#A lot of the code is hardcoded just for testing sake, but I'll change it
#####

from PyQt5 import QtCore, QtGui, QtWidgets
import matplotlib
import matplotlib.pyplot as plt
matplotlib.use('Qt5Agg')
from PyQt5.QtWidgets import QFileDialog, QDateTimeEdit, QDockWidget, QTabWidget, QTextEdit
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg, NavigationToolbar2QT as Navi
from matplotlib.figure import Figure
import datetime
import seaborn as sns
import pandas as pd
import numpy as py
import sip # can be installed : pip install sip
import os
import json
import shutil
import traceback


#Canvas class
class MatplotlibCanvas(FigureCanvasQTAgg):
    def __init__(self, parent=None,width=5, height = 5, dpi = 120):
        f = Figure(figsize = (width,height),dpi = dpi)
        self.axes= f.add_subplot(111)
        super(MatplotlibCanvas,self).__init__(f)
        f.tight_layout(pad=3)

#Column selction dialog box
class ColumnSelectionDialog(QtWidgets.QDialog):
    def __init__(self, columns, parent=None):
        super(ColumnSelectionDialog, self).__init__(parent)
        self.setWindowTitle("Select Columns To Read")
        self.resize(400, 300)

        self.layout = QtWidgets.QVBoxLayout(self)

        # Test description directing user
        self.description = QtWidgets.QLabel("Select an index column from you inputted CSV files and a data column:")
        self.layout.addWidget(self.description)

        # Selection of index columns
        self.index_group = QtWidgets.QGroupBox("Index Column (column that will tie all columns together ex:date-time)")
        self.index_layout = QtWidgets.QVBoxLayout(self.index_group)
        self.index_combo = QtWidgets.QComboBox()
        self.index_combo.addItems(columns)
        self.index_layout.addWidget(self.index_combo)
        self.layout.addWidget(self.index_group)

        # Selection of data columns
        self.data_group = QtWidgets.QGroupBox("Data Columns")
        self.data_layout = QtWidgets.QVBoxLayout(self.data_group)

        # Widget for adding spefic columns columns
        self.data_list = QtWidgets.QListWidget()
        self.data_list.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)
        for column in columns:
            item = QtWidgets.QListWidgetItem(column)
            self.data_list.addItem(item)
        self.data_layout.addWidget(self.data_list)
        self.layout.addWidget(self.data_group)

        # Rename selected columns widgets
        self.rename_group = QtWidgets.QGroupBox("Rename Selected Data Column (Optional)")
        self.rename_layout = QtWidgets.QHBoxLayout(self.rename_group)
        self.rename_label = QtWidgets.QLabel("New Name:")
        self.rename_edit = QtWidgets.QLineEdit()
        self.rename_button = QtWidgets.QPushButton("Set Name")
        self.rename_layout.addWidget(self.rename_label)
        self.rename_layout.addWidget(self.rename_edit)
        self.rename_layout.addWidget(self.rename_button)
        self.layout.addWidget(self.rename_group)

        # Connect rename button
        self.rename_button.clicked.connect(self.rename_selected)

        # Buttons for column selection
        self.button_box = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel
        )
        self.layout.addWidget(self.button_box)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)

        # Initialize choices
        self.selected_index = ""
        self.selected_data = []
        self.column_rename = {}
    #Rename selected column
    def rename_selected(self):
        selected_item = self.data_list.selectedItems()
        if selected_item and self.rename_edit.text().strip():
            colum_n = selected_item[0].text()
            new_name = self.rename_edit.text().strip()
            self.column_rename[colum_n] = new_name

            # Update show new names
            selected_item[0].setText(f"{colum_n} → {new_name}")

            # Clear the edit
            self.rename_edit.clear()
    #Takes in user selection from index and data
    def accept(self):
        self.selected_index = self.index_combo.currentText()
        self.selected_data = [item.text().split(" → ")[0] for item in
                              [self.data_list.item(i) for i in range(self.data_list.count())
                               if self.data_list.item(i).isSelected()]]

        # Error checking
        if not self.selected_index:
            QtWidgets.QMessageBox.warning(self, "Selection Error", "Please select an index column")
            return

        if not self.selected_data:
            QtWidgets.QMessageBox.warning(self, "Selection Error", "Please select at least one data column")
            return

        super(ColumnSelectionDialog, self).accept()

class AnomalyDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, anomaly_info=None):
        super(AnomalyDialog, self).__init__(parent)
        self.setWindowTitle("Anomaly Detection")
        self.resize(600, 400)
        
        # Main layout
        self.layout = QtWidgets.QVBoxLayout(self)
        
        #Detailed information label
        sensor_name = anomaly_info.get('sensor_name', 'Unknown')
        count = anomaly_info.get('count', 0)
        lower_bound = anomaly_info.get('global_lower_bound', 'N/A')
        upper_bound = anomaly_info.get('global_upper_bound', 'N/A')
        total_points = anomaly_info.get('total_points', 0)
        percent_anomalies = (count / total_points * 100) if total_points > 0 else 0
        
        info_text = (
            f"<h3>Anomalies Detected in {sensor_name} Sensor</h3>"
            f"<p>Total Anomalies: {count} </p>"
            f"<p>Total Anomalies: {count} out of {total_points} data points ({percent_anomalies:.2f}%)</p>"
            f"<p>Anomaly Thresholds:</p>"
            f"<ul>"
            f"<li>Lower Bound: {lower_bound:.2f}</li>"
            f"<li>Upper Bound: {upper_bound:.2f}</li>"
            f"</ul>"
            "<p>Choose how to handle these anomalies:</p>"
        )

        self.info_label = QtWidgets.QLabel(info_text)
        self.info_label.setWordWrap(True)
        self.layout.addWidget(self.info_label)
        
        # Create table to display anomalies
        self.table = QtWidgets.QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(["Timestamp", "Value"])
        self.table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.layout.addWidget(self.table)
        
        # Fill table with anomaly clean_data
        outliers = anomaly_info.get('values', pd.Series())

        #Ensure outliers index is datetime
        if len(outliers) > 0:
            self.table.setRowCount(len(outliers))
            
            #Process each outlier
            for i, (timestamp, value) in enumerate(outliers.items()):
                    #Handle timestamp formatting
                    if isinstance(timestamp, (pd.Timestamp, datetime.datetime)):
                        time_str = timestamp.strftime('%Y-%m-%d %H:%M:%S')
                    else:
                        #Try to convert to datetime if not already
                        try:
                            timestamp = pd.to_datetime(timestamp)
                            time_str = timestamp.strftime('%Y-%m-%d %H:%M:%S')
                        except:
                            #If all else fails, use string representation
                            time_str = str(timestamp)

                    #Create and add table items
                    time_item = QtWidgets.QTableWidgetItem(time_str)
                    value_item = QtWidgets.QTableWidgetItem(f"{value:.2f}")
                    self.table.setItem(i, 0, time_item)
                    self.table.setItem(i, 1, value_item)
        else:
            self.table.setRowCount(0)

        
        # Button group
        self.button_box = QtWidgets.QHBoxLayout()
        
        # Create options
        self.remove_button = QtWidgets.QPushButton("Remove Outliers")
        self.ignore_button = QtWidgets.QPushButton("Ignore Outliers")
        self.view_button = QtWidgets.QPushButton("View Outliers")
        
        self.button_box.addWidget(self.remove_button)
        self.button_box.addWidget(self.ignore_button)
        self.button_box.addWidget(self.view_button)
        self.layout.addLayout(self.button_box)
        
        # Connect buttons to actions
        self.remove_button.clicked.connect(self.accept_remove)
        self.ignore_button.clicked.connect(self.accept_ignore)
        self.view_button.clicked.connect(self.accept_view)
        
        # Result attribute to track user's choice
        self.result = "cancel"
        
    def accept_remove(self):
        self.result = "remove"
        self.accept()
        
    def accept_ignore(self):
        self.result = "ignore"
        self.accept()
    
    def accept_view(self):
        self.result = "view"
        self.accept()

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")

        #Horizontal layout for controls
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")

        #Theme selection
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)

        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox.setObjectName("comboBox")
        self.horizontalLayout.addWidget(self.comboBox)

        #File open button
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setObjectName("pushButton")
        self.horizontalLayout.addWidget(self.pushButton)

        #Spacer item to space out widgets to the left
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)

        #Vertical layout for the plot
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(self.spacerItem1)
        self.gridLayout.addLayout(self.verticalLayout, 1, 0, 1, 1)

        MainWindow.setCentralWidget(self.centralwidget)

        #Menu bar
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)

        #Status bar
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        #Actions
        self.actionOpen_CSV = QtWidgets.QAction(MainWindow)
        self.actionOpen_CSV.setObjectName("actionOpen_CSV")
        self.actionExit = QtWidgets.QAction(MainWindow)
        self.actionExit.setObjectName("actionExit")
        self.menuFile.addAction(self.actionOpen_CSV)
        self.menuFile.addAction(self.actionExit)
        self.menubar.addAction(self.menuFile.menuAction())

        #Start time selection
        self.startTimeLabel = QtWidgets.QLabel(self.centralwidget)
        self.startTimeLabel.setText("Start Time:")
        self.horizontalLayout.addWidget(self.startTimeLabel)

        self.startTimeEdit = QDateTimeEdit(self.centralwidget)
        self.startTimeEdit.setCalendarPopup(True)
        self.horizontalLayout.addWidget(self.startTimeEdit)

        #End time selection
        self.endTimeLabel = QtWidgets.QLabel(self.centralwidget)
        self.endTimeLabel.setText("End time:")
        self.horizontalLayout.addWidget(self.endTimeLabel)

        self.endTimeEdit = QDateTimeEdit(self.centralwidget)
        self.endTimeEdit.setCalendarPopup(True)
        self.horizontalLayout.addWidget(self.endTimeEdit)

        #Plot type selection
        self.plotTypeLabel = QtWidgets.QLabel(self.centralwidget)
        self.plotTypeLabel.setObjectName("plotTypeLabel")
        self.plotTypeLabel.setText("Plot Type:")
        self.horizontalLayout.addWidget(self.plotTypeLabel)

        self.plotTypeComboBox = QtWidgets.QComboBox(self.centralwidget)
        self.plotTypeComboBox.setObjectName("plotTypeComboBox")
        self.plotTypeComboBox.addItems(["Line Graph", "Bar Graph", "Histogram", "Box Plot","Heat Map"])
        self.horizontalLayout.addWidget(self.plotTypeComboBox)

        #Nake Create Project button and put it on GUI
        self.createProB = QtWidgets.QPushButton(self.centralwidget)
        self.createProB.setObjectName("createProB")
        self.createProB.setText("Create Project")
        self.horizontalLayout.addWidget(self.createProB)

        #Get img file button
        self.getIMGButton = QtWidgets.QPushButton(self.centralwidget)
        self.getIMGButton.setObjectName("getIMGButton")
        self.getIMGButton.setText("Upload Image")
        self.horizontalLayout.addWidget(self.getIMGButton)


        #Make Save Project button and put it on GUI
        self.saveProB = QtWidgets.QPushButton(self.centralwidget)
        self.saveProB.setObjectName("saveProB")
        self.saveProB.setText("Save Project")
        self.horizontalLayout.addWidget(self.saveProB)

        #Make Load Project button and put it on GUI
        self.loadProB = QtWidgets.QPushButton(self.centralwidget)
        self.loadProB.setObjectName("loadProB")
        self.loadProB.setText("Load Project")
        self.horizontalLayout.addWidget(self.loadProB)

        #Make Clear Data button and put it on GUI
        self.clearDataB = QtWidgets.QPushButton(self.centralwidget)
        self.clearDataB.setObjectName("clearDataB")
        self.clearDataB.setText("Clear Data")
        self.horizontalLayout.addWidget(self.clearDataB)


        #Setting up file name var, canvas, dataframe and toolbar
        self.filenames = ''
        self.imgfile =''
        self.filenames =''
        self.canv = MatplotlibCanvas(self)
        self.df = pd.DataFrame()
        self.toolbar = Navi(self.canv,self.centralwidget)
        self.horizontalLayout.addWidget(self.toolbar)
        self.column_selection = {}
        self.rename_dict = {}
        self.cleaned_anomaly_columns = set()
        self.ignored_anomaly_columns = set()
        self.sensor_states = {}

        self.sensor_states = {} #Key: sensor name, Value: dict of state/data

        #Create a dock widget for statistics
        self.statsDockWidget = QDockWidget("Statistics Panel", MainWindow)
        self.statsDockWidget.setFeatures(
            QDockWidget.DockWidgetMovable |
            QDockWidget.DockWidgetFloatable |
            QDockWidget.DockWidgetClosable
        )
        MainWindow.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.statsDockWidget)

        #Create a tab widget for statistics
        self.statsTabWidget = QTabWidget()
        self.statsDockWidget.setWidget(self.statsTabWidget)
        
        #Themes for plotting -- make sure that all of the themes are installed locally otherwise
        #will cause crashes when selected
        self.themes = ['bmh', 'classic', 'dark_background',
                       'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-bright',
                       'seaborn-colorblind', 'seaborn-dark-palette', 'seaborn-dark',
                       'seaborn-darkgrid', 'seaborn-deep', 'seaborn-muted', 'seaborn-notebook',
                       'seaborn-paper', 'seaborn-pastel', 'seaborn-poster', 'seaborn-talk',
                       'seaborn-ticks', 'seaborn-white', 'seaborn-whitegrid', 'seaborn',
                       'Solarize_Light2', 'tableau-colorblind10']

        self.comboBox.addItems(self.themes)

        #Connect signals and slots
        self.pushButton.clicked.connect(self.getFileCSV)
        self.createProB.clicked.connect(self.createP)
        self.saveProB.clicked.connect(self.saveP)
        self.loadProB.clicked.connect(self.loadP)
        self.clearDataB.clicked.connect(self.clearD)
        self.getIMGButton.clicked.connect(self.getFileIMG)


        self.comboBox.currentIndexChanged['QString'].connect(self.update) #For changing theme comboBox
        self.plotTypeComboBox.currentIndexChanged.connect(self.update) #For changing plot type
        self.startTimeEdit.dateTimeChanged.connect(self.update) #For changing time ranges of graph
        self.endTimeEdit.dateTimeChanged.connect(self.update)

        #Finalize UI
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def createP(self):
        #A dialog box is opened and the user is propmted to select a project folder
        f =QFileDialog.getExistingDirectory(None,"Select Project Folder")
        #The project folder directory stored above is saved into a dictory which uses the directory as a key
        #and the files saved in that directory as a path. This will later be stored in a json file
        if f:
            self.pFold = f
            self.pData ={
                "pf":self.pFold, "files":[]}
        else:
            return
        #Creates a subfolder in the main project folder called datafiles which will store the copied CSV files that are uploaded to the project.
        #It will not be created if there already exists one
        self.dataF = os.path.join(self.pFold,"datafiles")
        os.makedirs(self.dataF,exist_ok =True)
        print(f"Project has been made: {self.pFold}")

    def saveP(self):
        #Makes sure that a project has be created
        if not hasattr(self,"pFold") or not self.pFold:
            print("There isn't a project folder to select")
            return
        #Makes sure the datafile subfolder has been made
        self.dataF = os.path.join(self.pFold,"clean_data")
        os.makedirs(self.dataF,exist_ok =True)



        #List is made for copied files and the loop puts each csv file into datafile folder
        localF = []
        for f in self.filenames:
            try:
                #Creates destination path for copied files and copies the files into destination (datafile folder)
                projPath = os.path.join(self.dataF, os.path.basename(f))
                shutil.copy2(f,projPath)
                #File names are added to list
                localF.append(os.path.basename(f))
            except Exception as e:
                print(f"Error copying file {f}: {e}")

        #List is used to update list and stores file paths into json file
        self.pData["files"] =localF
        pf = os.path.join(self.pFold,"proj.json")
        with open(pf,"w") as i:
            json.dump(self.pData,i,indent = 4)

        print(f"Project saved to {pf}")

    def loadP(self):
        #Prompt user to select file(json project file)
        file,_ = QFileDialog.getOpenFileName(filter = "Project Files (*.json)")
        #If a file is not selected a meesge will show and exit the prompy
        if not file:
            print("No Project Selected")
            return
        #Parses and read json file
        try:
            with open(file,"r") as i:
                self.pData = json.load(i)
            #Gets file paths from json
            self.pFold =self.pData.get("pf","")
            self.dataF = os.path.join(self.pFold, "clean_data")
            os.makedirs(self.dataF, exist_ok=True)
            self.filenames = [os.path.join(self.dataF, f) for f in self.pData.get("files", [])]


            if not self.filenames:
                print("No files found")

            self.readData()
            self.update(self.themes[0])

        except Exception as e:
            print(f"Error loading in project: {e}")

    def clearD(self):
        self.df =pd.DataFrame()
        self.filenames = []
        #Reset anomaly handling state
        self.sensor_states = {}
        if hasattr(self, 'processed_files'):
            delattr(self, 'processed_files')
 
        self.update(self.themes[0])
        print("Data has been cleared")

    def update(self,v=None):
        #If v is a QDateTime object (from dateTimeChanged signal) or int(PlotTypeComboBox), ignore it for error reasons
        if isinstance(v, QtCore.QDateTime) | isinstance(v, int):
            v = self.comboBox.currentText() #Use the current theme
        
        print("V from CB: ", v)
        plt.clf()
        plt.style.use(v)
        # Save current figure size before deleting
        if hasattr(self, 'canv'):
            old_width, old_height = self.canv.figure.get_size_inches()
        else:
            old_width, old_height = 8, 6  # Default size

        try:
            self.horizontalLayout.removeWidget(self.toolbar)
            self.verticalLayout.removeWidget(self.canv)

            #Remove spacerItem1 if it exists
            if hasattr(self, 'spacerItem1'):
                self.verticalLayout.removeItem(self.spacerItem1)

            sip.delete(self.toolbar)
            sip.delete(self.canv)
            self.toolbar = None
            self.canv = None

        except Exception as e:
            print(e)
            pass
        
        #Create new canvas and toolbar
        self.canv = MatplotlibCanvas(self, width=old_width, height=old_height)
        self.toolbar = Navi(self.canv,self.centralwidget)

        #Add spacerItem1 if it doesn't exist
        if not hasattr(self, 'spacerItem1'):
            self.spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
            self.verticalLayout.addWidget(self.canv)
        
        #Rebuild layout
        self.horizontalLayout.addWidget(self.toolbar)
        self.verticalLayout.addWidget(self.canv)

        #Clear the axes
        self.canv.axes.cla()
    
        if not self.df.empty:
            try: 
                # Process anomaly dialogs using sensor_states
                for sensor_col in list(self.sensor_states.keys()):
                    state = self.sensor_states[sensor_col]
                    
                    # Skip if already processed
                    if state['status'] in ('cleaned', 'ignored', 'viewed'):
                        continue
                    
                    # Only show dialog if we have anomalies
                    if not state['anomalies'].empty:
                        dialog = AnomalyDialog(MainWindow, {
                            'sensor_name': sensor_col.replace("Temperature_", ""),
                            'count': len(state['anomalies']),
                            'values': state['anomalies'],
                            'global_lower_bound': state['bounds']['lower'],
                            'global_upper_bound': state['bounds']['upper'],
                            'total_points': len(state['original_data'])
                        })
                        
                        result = dialog.exec_()

                        if result == QtWidgets.QDialog.Accepted:
                            if dialog.result == "remove":
                                # Create cleaned version
                                cleaned_data = state['original_data'].copy()
                                cleaned_data.loc[state['anomalies'].index] = None
                                cleaned_data = cleaned_data.ffill().bfill()
                                
                                # Update state in sensor_states
                                self.sensor_states[sensor_col].update({
                                    'status': 'cleaned',
                                    'processed_data': cleaned_data
                                })
                                
                            elif dialog.result == "ignore":
                                self.sensor_states[sensor_col]['status'] = 'ignored'
                                
                            elif dialog.result == "view":
                                self.sensor_states[sensor_col]['status'] = 'viewed'
                
                # Rebuild main dataframe after any changes
                dfs = []
                for sensor_name, state in self.sensor_states.items():
                    dfs.append(state['processed_data'])
                
                self.df = pd.concat(dfs, axis=1) if dfs else pd.DataFrame()
                #Make sure that no rows exist without data
                self.df = self.df.sort_index().dropna(axis=0)

                #Write altered to CSV
                os.makedirs('datafiles', exist_ok=True)
                file_path = os.path.join('datafiles', 'alteredDF.csv')
                self.df.to_csv(file_path)

                #Update statistics
                self.updateStatistics()

                #Get plot type
                plotType = self.plotTypeComboBox.currentText()
                #Get filtered clean_data based on selected time range
                startTime = self.startTimeEdit.dateTime().toPyDateTime()
                endTime = self.endTimeEdit.dateTime().toPyDateTime()

                #Ensure the DataFrame index is datetime
                if not isinstance(self.df.index, pd.DatetimeIndex):
                    self.df.index = pd.to_datetime(self.df.index)

                #Compare it to the original dateTime detected when importing 
                if startTime < self.df.index.min():
                    startTime = self.df.index.min()
                    raise Exception("Start time cannot be before the original start time!")
                elif endTime > self.df.index.max():
                    endTime = self.df.index.max()
                    raise Exception("End time cannot be after original end time!")
            
                filtered_df = self.df[(self.df.index >= startTime) & (self.df.index <= endTime)]
                
                if plotType == "Line Graph":
                    #First plot all clean_data points regardless of anomaly status
                    for c in filtered_df.columns:
                        if not filtered_df[c].empty:
                            self.canv.axes.plot(filtered_df.index, filtered_df[c], label = c)

                    # Modified anomaly plotting:
                    for sensor_col, state in self.sensor_states.items():
                        if state['status'] == 'viewed' and not state['anomalies'].empty:
                            outliers = self.sensor_states[sensor_col]['anomalies']
                            if not outliers.empty:
                                try:
                                    valid_outliers = outliers[(outliers.index >= startTime) & 
                                                             (outliers.index <= endTime)]
                                    if not valid_outliers.empty:
                                        self.canv.axes.scatter(
                                            valid_outliers.index, 
                                            valid_outliers.values, 
                                            color='red', 
                                            s=5, 
                                            label=f"{sensor_col.replace('Temperature_', '')} outliers",
                                            zorder=3
                                        )
                                except Exception as e:
                                    print(f"Error plotting outliers: {e}")

                    # Configure plot with larger fonts
                    plt.rcParams.update({'font.size': 10})  # Set base font size

                    self.canv.axes.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%Y-%m-%d'))
                    self.canv.axes.xaxis.set_major_locator(matplotlib.dates.AutoDateLocator())
                    # Rotate and adjust x-axis labels with larger font
                    plt.setp(self.canv.axes.get_xticklabels(), rotation=45, ha='right', fontsize=10)
                    plt.setp(self.canv.axes.get_yticklabels(), fontsize=10)
                    legend = self.canv.axes.legend()
                    legend.set_draggable(True)
                    self.canv.axes.set_xlabel('Date-Time', fontsize=18)
                    self.canv.axes.set_ylabel('Measured Temperature(°C)', fontsize=18)
                    self.canv.axes.set_title('Temperature in Cave Over Time', fontsize=22, pad=20)
  
                elif plotType == "Bar Graph":
                    try:
                        # For bar graphs, resample the data to a suitable frequency
                        # First ensure we have a proper datetime index
                        if not isinstance(filtered_df.index, pd.DatetimeIndex):
                            filtered_df.index = pd.to_datetime(filtered_df.index)

                        # Determine appropriate frequency based on date range
                        date_range = (filtered_df.index.max() - filtered_df.index.min()).total_seconds()
                        
                        if date_range > 60*60*24*30:  # More than a month
                            freq = 'W'  # Weekly
                            freq_label = 'Weekly'
                        elif date_range > 60*60*24*7:  # More than a week
                            freq = 'D'  # Daily
                            freq_label = 'Daily'
                        elif date_range > 60*60*24:  # More than a day
                            freq = '6H'  # 6-hourly
                            freq_label = '6-Hourly'
                        else:
                            freq = 'H'  # Hourly
                            freq_label = 'Hourly'

                        agg_method = "min"
                       
                        # Apply aggregation based on selected method
                        if agg_method == "mean":
                            agg_df = filtered_df.resample(freq).mean()
                        elif agg_method == "median":
                            agg_df = filtered_df.resample(freq).median()
                        elif agg_method == "min":
                            agg_df = filtered_df.resample(freq).min()
                        elif agg_method == "max":
                            agg_df = filtered_df.resample(freq).max()
                        elif agg_method == "sum":
                            agg_df = filtered_df.resample(freq).sum()
                        elif agg_method == "count":
                            agg_df = filtered_df.resample(freq).count()
                        else:
                            # Default to mean
                            agg_df = filtered_df.resample(freq).mean()
                        # Calculate bar width based on number of columns
                        num_cols = len(agg_df.columns)
                        width = 0.8 / num_cols if num_cols > 0 else 0.8
                        
                        # Convert datetime index to numerical values for plotting
                        dates_num = matplotlib.dates.date2num(agg_df.index)
                        
                        # Plot each column as a separate bar series
                        for i, col in enumerate(agg_df.columns):
                            # Calculate position for this set of bars
                            pos = dates_num + (i * width)
                            self.canv.axes.bar(pos, agg_df[col], width=width, label=col)
                        
                        # Configure plot
                        self.canv.axes.set_xlabel('Time Period')
                        self.canv.axes.set_ylabel(f'{agg_method.capitalize()} Temperature (°C)')
                        self.canv.axes.set_title(f'{freq_label} {agg_method.capitalize()} Temperature')
                        
                        # Format x-axis as dates
                        self.canv.axes.xaxis.set_major_formatter(matplotlib.dates.DateFormatter('%Y-%m-%d'))
                        self.canv.axes.xaxis.set_major_locator(matplotlib.dates.AutoDateLocator())
                        plt.setp(self.canv.axes.get_xticklabels(), rotation=45, ha='right')
                        
                        # Add legend
                        if num_cols > 0:
                            legend = self.canv.axes.legend()
                            legend.set_draggable(True)
                    
                    except Exception as e:
                        print(f"Error in bar graph plotting: {e}")
                        raise

                elif plotType == "Histogram":
                    # We'll create a histogram for each column with transparency
                    bins = 20  # Number of bins
                    
                    for col in filtered_df.columns:
                        # Remove NaN values for histogram
                        clean_data = filtered_df[col].dropna()
                        
                        # Only create histogram if we have clean_data
                        if len(clean_data) > 0:
                            self.canv.axes.hist(clean_data, bins=bins, alpha=0.7, label=col)
                    
                    # Configure plot
                    self.canv.axes.set_xlabel('Temperature (°C)')
                    self.canv.axes.set_ylabel('Frequency')
                    self.canv.axes.set_title('Temperature Distribution')
                    legend = self.canv.axes.legend()
                    legend.set_draggable(True)
                    
                elif plotType == "Box Plot":
                    # For box plots, we need to prepare the clean_data differently
                    # We'll create a list of clean_data for each column
                    clean_data = []
                    labels = []
                    
                    for col in filtered_df.columns:
                        # Only add column if it has non-NaN values
                        if not filtered_df[col].isna().all():
                            clean_data.append(filtered_df[col].dropna())
                            labels.append(col)
                    
                    # Create box plot
                    if clean_data:
                        self.canv.axes.boxplot(clean_data, labels=labels, patch_artist=True)
                        
                        # Configure plot
                        self.canv.axes.set_xlabel('Sensor')
                        self.canv.axes.set_ylabel('Temperature (°C)')
                        self.canv.axes.set_title('Temperature Distribution by Sensor')
                        self.canv.axes.grid(True, linestyle='--', alpha=0.7)

                self.canv.draw()
                self.canv.figure.tight_layout()


            except Exception as e:
                print("Plotting error:", e)
                traceback.print_exc()

    def updateStatistics(self):
        #Clear existing tabs
        self.statsTabWidget.clear()
        
        #Get filtered clean_data based on selected time range
        startTime = self.startTimeEdit.dateTime().toPyDateTime()
        endTime = self.endTimeEdit.dateTime().toPyDateTime()
        filtered_df = self.df[(self.df.index >= startTime) & (self.df.index <= endTime)]

        #Add a tab for each sensor
        for column in filtered_df.columns:
            if column.startswith("Temperature_"):
                sensorName = column.replace("Temperature_", "")
                statsText = self.calculateStatistics(filtered_df[column])

                #Create a QTextEdit for the statistics
                textEdit = QTextEdit()
                textEdit.setReadOnly(True)
                textEdit.setText(statsText)
                
                #Add the QTextEdit to a new tab
                self.statsTabWidget.addTab(textEdit, sensorName)

    def detectAnomalies(self, data):
        """
        Enhanced anomaly detection with better spike handling and duplicate management
        """
        clean_data = data.dropna()
        sensor_name = clean_data.name.replace("Temperature_", "") if hasattr(clean_data, 'name') else "Unknown"

        if clean_data.empty:
            return {
                "count": 0,
                "values": pd.Series(dtype=float),
                "global_lower_bound": None,
                "global_upper_bound": None,
                "total_points": 0,
                "sensor_name": sensor_name
            }

        # Calculate quartiles and IQR
        Q1 = clean_data.quantile(0.25, interpolation='midpoint')
        Q3 = clean_data.quantile(0.75, interpolation='midpoint')
        IQR = Q3 - Q1

        # Identify IQR outliers
        threshold = 1.5
        lower_bound = Q1 - threshold * IQR
        upper_bound = Q3 + threshold * IQR
        iqr_outliers = clean_data[(clean_data < lower_bound) | (clean_data > upper_bound)]
        
        # Spike detection with adaptive threshold
        diff = clean_data.diff().abs()
        if not diff.empty:
            # Dynamic spike threshold based on rolling window
            rolling_std = diff.rolling(window=10, min_periods=1).std()
            spike_threshold = 3 * rolling_std  # 3 standard deviations
            spike_outliers = clean_data[diff > spike_threshold]
            
            # Combine outliers while preserving important cases
            combined_outliers = pd.concat([iqr_outliers, spike_outliers])
            
            # Smart de-duplication - keep all if they're significant spikes
            if not combined_outliers.empty:
                # Only remove duplicates that aren't significant spikes
                mask = (combined_outliers.index.duplicated(keep='first') & 
                    (diff.loc[combined_outliers.index] < 2 * rolling_std.loc[combined_outliers.index]))
                outliers = combined_outliers[~mask]
            else:
                outliers = combined_outliers
        else:
            outliers = iqr_outliers

        return {
            "count": len(outliers),
            "values": outliers.sort_values(),
            "global_lower_bound": lower_bound,
            "global_upper_bound": upper_bound,
            "total_points": len(clean_data),
            "sensor_name": sensor_name,
            "iqr_outliers": len(iqr_outliers),
            "spike_outliers": len(outliers) - len(iqr_outliers)
        }  
  
    def calculateStatistics(self, clean_data):
        try:
            # Ensure numeric clean_data
            numeric_data = pd.to_numeric(clean_data, errors='coerce')
            valid_data = numeric_data[py.isfinite(numeric_data)]
            
            if len(valid_data) == 0:
                return "No valid numeric clean_data"
            
            stats = {
                "Min": float(py.nanmin(valid_data)),
                "Max": float(py.nanmax(valid_data)),
                "Mean": float(py.nanmean(valid_data)),
                "Median": float(py.nanmedian(valid_data)),
                "Std Dev": float(py.nanstd(valid_data)),
                "Count": int(len(valid_data))
            }
            
            return "\n".join([f"{k}: {v:.2f}" if k != "Count" else f"{k}: {v}" 
                            for k, v in stats.items()])
        
        except Exception as e:
            return f"Statistics error: {str(e)}"

    def getFileCSV(self):
        #Will get file address of csv file and read it
        files,_ = QFileDialog.getOpenFileNames(filter="CSV Files (*.csv)")
        if files:
            self.filenames = files
            print("Files :", self.filenames)
            #Place to store column selction
            self.column_selection = {}

            for file in files:
                try:
                    sample_df =pd.read_csv(file, nrows=0, encoding='utf-8')
                    column = sample_df.columns.tolist()

                    #Dialog box shows up to select columns
                    dial = ColumnSelectionDialog(column)
                    if dial.exec_() == QtWidgets.QDialog.Accepted:
                        self.column_selection[file] = {
                            'index': dial.selected_index,
                            'data': dial.selected_data,
                            'renames': dial.column_rename
                        }
                    else:
                        # If a user cancels selection, remove that file
                        self.filenames.remove(file)
                #if there is am error reading in the columns, remove if from the list
                except Exception as e:
                    print(f"Error reading columns from {file}: {e}")
                    self.filenames.remove(file)
            #Once the files are read in and the columns are selected, they put through readData
            if self.filenames:
                self.readData()
            else:
                print("No valid files selected.")
        else:
            print("No files selected.")

    def getFileIMG(self):
        #Will get file address of img file and read it
        file,_ = QFileDialog.getOpenFileName(filter = "Images (*.png *.xpm *.jpg)");
        if file:
            self.imgfile = file
            print("Files :", self.imgfile)
        else:
            print("No files selected.")

    def readData(self):
    
        """
        Takes csv file(s) and returns a dataframe with index as datetime and datatype as columns.
        
        """

        #First pass: Read and preprocess all files
        merged_dfs = []
        for file in self.filenames:
            try:
                # Get column selections for this file
                if file not in self.column_selection:
                    print(f"No column selections for {file}, skipping file")
                    continue

                select = self.column_selection[file]
                index_col = select['index']
                data_col = select['data']
                rename = select['renames']

                sensor_name = os.path.basename(file).split('.')[0]

                # Skip if this sensor has already been processed this session
                # if temp_col_name in self.cleaned_anomaly_columns or temp_col_name in self.ignored_anomaly_columns:
                #   continue

                try:
                    # reads the csv files, only the selected columns, and saves it into a dataframe
                    cols = [index_col] + data_col
                    single_df = pd.read_csv(
                        file, encoding='utf-8',
                        usecols=cols
                    )
                except ValueError as e:
                    print(f"Missing required columns in {file}: {e}")
                    continue

                # Validate data content
                if single_df.empty:
                    print(f"No data in {file}")
                    continue

                try:
                    # formats the date time column so that it is readable by matplotlib
                    single_df[index_col] = pd.to_datetime(single_df[index_col],
                                                          errors="coerce")
                    # Drop rows with invalid dates
                    single_df = single_df.dropna(subset=[index_col])
                except Exception as e:
                    print(f"Can't convert {index_col} to datetime: {e}")
                    continue

                # Set index
                single_df = single_df.set_index(index_col)

                # Save rename choices
                rename_dict = {}
                for col in data_col:
                    if col in rename:
                        new_name = f"{renames[col]}_{sensor_name}"
                    else:
                        new_name = f"{col}_{sensor_name}"
                    rename_dict[col] = new_name

                single_df = single_df.rename(columns=rename_dict)
                # if the index is datetime
                if isinstance(single_df.index, pd.DatetimeIndex):
                    # Calculate time differences to detect sampling rate
                    time_diffs = single_df.index.to_series().diff()
                    sampling_interval = '2min'

                    if not time_diffs.empty:
                        # Get the most common time difference (mode) to determine sampling rate
                        sampling_interval = time_diffs.mode().iloc[0] if not time_diffs.empty else pd.Timedelta(0)
                        print(f"Detected sampling interval: {sampling_interval}")
                    else:
                        print("Warning: Could not determine sampling interval for input data")

                    # Resample to consistent interval (e.g. 2 minutes)
                    single_df = single_df.resample(sampling_interval).mean().interpolate(method='linear')

                # Process each column for anomalies and store in sensor states
                for col in single_df.columns:
                    # Skip if this column has already been processed this session
                    if col in self.cleaned_anomaly_columns or col in self.ignored_anomaly_columns:
                        continue
                try:
                    # Detect anomalies
                    anomaly_info = self.detectAnomalies(single_df[col])

                 # Store initial state
                    self.sensor_states[col] = {
                        'status': 'raw',
                        'original_data': single_df[[col]].copy(),
                        'processed_data': single_df[[col]].copy(),
                        'anomalies': anomaly_info['values'],
                        'bounds': {
                            'lower': anomaly_info['global_lower_bound'],
                            'upper': anomaly_info['global_upper_bound']
                        }

                }
                except Exception as e:
                    print(f"Warning: Error detecting anomalies the following columns: {col}: {str(e)}")
                    traceback.print_exc()
                    # Continue processing other columns
                    continue
                merged_dfs.append(single_df)

            except Exception as e:
                print(f"Error processing {file}: {str(e)}")
                traceback.print_exc()
                continue

        # Build main dataframe from sensor states
        dfs = []
        for sensor, state in self.sensor_states.items():
            dfs.append(state['processed_data'])
        
        self.df = pd.concat(dfs, axis=1) if dfs else pd.DataFrame()    

        if not self.df.empty:
            self.df.index = pd.to_datetime(self.df.index)
            self.df = self.df.sort_index().dropna(axis=0)
            
            # Update time range controls

            self.startTimeEdit.blockSignals(True)
            self.endTimeEdit.blockSignals(True)
            self.startTimeEdit.setDateTime(QtCore.QDateTime(self.df.index.min()))
            self.endTimeEdit.setDateTime(QtCore.QDateTime(self.df.index.max()))
            self.startTimeEdit.blockSignals(False)
            self.endTimeEdit.blockSignals(False)
            
            # Write CSV
            os.makedirs('datafiles', exist_ok=True)
            file_path = os.path.join('datafiles', 'originalDF.csv')
            self.df.to_csv(file_path)
            
            self.updateStatistics()
            self.update(self.themes[0])
        

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label.setText(_translate("MainWindow", "Select Theme"))
        self.pushButton.setText(_translate("MainWindow", "Open"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.actionOpen_CSV.setText(_translate("MainWindow", "Open CSV"))
        self.actionExit.setText(_translate("MainWindow", "Exit"))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
